{
  "version": 3,
  "sources": ["../src/ByteScanner.ts"],
  "sourcesContent": [
    "import fs from \"fs\";\n\ntype Byte = number;\ntype BytePattern = Byte[];\ntype ByteIndex = number;\ntype FilePath = string;\ntype PatternString = string;\ntype BufferSpec = FilePath | Buffer;\n\ninterface LastOccurrenceMap {\n  [byte: number]: number;\n}\n\ninterface ByteScannerOptions {\n  bufferSpec: FilePath;\n}\n\ninterface ByteScannerResult {\n  indexes: ByteIndex[];\n  pattern: BytePattern;\n}\n\ninterface Scanner {\n  setPattern(pattern: PatternString): void;\n  scan(): ByteScannerResult;\n}\n\nclass ByteScanner implements Scanner {\n  private pattern: BytePattern = [];\n  private fileBuffer: Buffer;\n\n  constructor(private bufferSpec: BufferSpec) {\n    this.fileBuffer = this.isBuffer(this.bufferSpec)\n      ? this.bufferSpec\n      : fs.readFileSync(this.bufferSpec);\n  }\n\n  private isBuffer(input: any): input is Buffer {\n    return Buffer.isBuffer(input);\n  }\n\n  private parsePattern(pattern: PatternString): BytePattern {\n    return pattern.split(\" \").map((byte) => {\n      if (byte === \"??\") {\n        return -1;\n      } else {\n        return parseInt(byte, 16);\n      }\n    });\n  }\n\n  private boyerMooreSearch(buffer: Buffer): ByteIndex[] {\n    const pattern = this.pattern;\n    const patternLength = pattern.length;\n    const bufferLength = buffer.length;\n    const lastOccurrence: LastOccurrenceMap = {};\n\n    pattern.forEach((byte, index) => {\n      lastOccurrence[byte] = index;\n    });\n\n    const indexes: ByteIndex[] = [];\n    let i = 0;\n\n    while (i <= bufferLength - patternLength) {\n      let j = patternLength - 1;\n      while (j >= 0 && (pattern[j] === buffer[i + j] || pattern[j] === -1)) {\n        j--;\n      }\n      if (j < 0) {\n        indexes.push(i);\n        i += patternLength;\n      } else {\n        const lastOcc = lastOccurrence[buffer[i + j]];\n        const shift = Math.max(1, j - (lastOcc !== undefined ? lastOcc : -1));\n        i += shift;\n      }\n    }\n\n    return indexes;\n  }\n\n  public setPattern(pattern: PatternString): void {\n    this.pattern = this.parsePattern(pattern);\n  }\n\n  public scan(): ByteScannerResult {\n    const indexes = this.boyerMooreSearch(this.fileBuffer);\n    return indexes\n  }\n}\n\nfunction hexStrToBuf(hexString: string): Buffer {\n  return Buffer.from(hexString.replace(/\\s+/g, \"\"), \"hex\");\n}\n\nexport {\n  hexStrToBuf,\n  ByteScanner,\n  ByteScannerOptions,\n  BytePattern,\n  ByteIndex,\n  Byte,\n  ByteScannerResult,\n  Scanner,\n  FilePath,\n  PatternString,\n};\n"
  ],
  "mappings": ";AAAA;AA4FA,IAAS,sBAAW,CAAC,WAA2B;AAC9C,SAAO,OAAO,KAAK,UAAU,QAAQ,QAAQ,EAAE,GAAG,KAAK;AAAA;AAlEzD;AAAA,MAAM,YAA+B;AAAA,EAIf;AAAA,EAHZ,UAAuB,CAAC;AAAA,EACxB;AAAA,EAER,WAAW,CAAS,YAAwB;AAAxB;AAClB,SAAK,aAAa,KAAK,SAAS,KAAK,UAAU,IAC3C,KAAK,aACL,GAAG,aAAa,KAAK,UAAU;AAAA;AAAA,EAG7B,QAAQ,CAAC,OAA6B;AAC5C,WAAO,OAAO,SAAS,KAAK;AAAA;AAAA,EAGtB,YAAY,CAAC,SAAqC;AACxD,WAAO,QAAQ,MAAM,GAAG,EAAE,IAAI,CAAC,SAAS;AACtC,UAAI,SAAS,MAAM;AACjB,gBAAO;AAAA,MACT,OAAO;AACL,eAAO,SAAS,MAAM,EAAE;AAAA;AAAA,KAE3B;AAAA;AAAA,EAGK,gBAAgB,CAAC,QAA6B;AACpD,UAAM,UAAU,KAAK;AACrB,UAAM,gBAAgB,QAAQ;AAC9B,UAAM,eAAe,OAAO;AAC5B,UAAM,iBAAoC,CAAC;AAE3C,YAAQ,QAAQ,CAAC,MAAM,UAAU;AAC/B,qBAAe,QAAQ;AAAA,KACxB;AAED,UAAM,UAAuB,CAAC;AAC9B,QAAI,IAAI;AAER,WAAO,KAAK,eAAe,eAAe;AACxC,UAAI,IAAI,gBAAgB;AACxB,aAAO,KAAK,MAAM,QAAQ,OAAO,OAAO,IAAI,MAAM,QAAQ,QAAO,IAAK;AACpE;AAAA,MACF;AACA,UAAI,IAAI,GAAG;AACT,gBAAQ,KAAK,CAAC;AACd,aAAK;AAAA,MACP,OAAO;AACL,cAAM,UAAU,eAAe,OAAO,IAAI;AAC1C,cAAM,QAAQ,KAAK,IAAI,GAAG,KAAK,YAAY,YAAY,WAAU,EAAG;AACpE,aAAK;AAAA;AAAA,IAET;AAEA,WAAO;AAAA;AAAA,EAGF,UAAU,CAAC,SAA8B;AAC9C,SAAK,UAAU,KAAK,aAAa,OAAO;AAAA;AAAA,EAGnC,IAAI,GAAsB;AAC/B,UAAM,UAAU,KAAK,iBAAiB,KAAK,UAAU;AACrD,WAAO;AAAA;AAEX;",
  "debugId": "C1314AA24272224164756e2164756e21",
  "names": []
}